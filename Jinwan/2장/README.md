# 2장 실행 컨텍스트

## 실행 컨텍스트란?

실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 `객체`다. 클로저를 지원하는 대부분의 언어가 이와 유사한 개념을 적용하고 있다. 실행 컨텍스트를 구성하는 방법은 `함수를 실행하는 것뿐이다.`

처음 자바스크립트 코드가 실행될 때, 전역 컨텍스트를 실행 컨텍스트 스택에 들어가게 된다. 이후 함수가 호출될 때마다 해당 함수의 실행 컨텍스트가 스택에 쌓이게 된다. 함수가 종료되면, 해당 함수의 컨텍스트가 스택에서 `pop`되게 된다. 이런 식으로 진행되다가 마지막에 전역 컨텍스트가 스택에서 빠져나오게 되면 코드가 종료되는 것이다.

실행 컨텍스트에 담겨있는 정보는 `VariableEnvironment`, `LexicalEnvironment`, `ThisBinding`이 있다.

변수 환경은 최초 실행 시의 컨텍스트 내 식별자 정보와 외부 환경 정보, 선언 시점의 렉시컬 환경의 스냅샷을 가진다. 이후 이를 그대로 복사해 렉시컬 환경을 만들고, 컨텍스트는 이 렉시컬 환경을 활용하게 된다.

## 스코프

스코프는 범위라는 뜻을 가지고 있다. 프로그래밍에서 스코프는 식별자의 유효 `범위`를 의미한다.

스코프는 크게 `전역 스코프`와 `지역 스코프`로 나눌 수 있다. 전역은 코드의 제일 바깥 부분을 의미하고, 지역은 함수 내부를 의미한다. 각 스코프에서 생성한 변수들을 우리는 **전역 변수와 지역 변수**라고 부른다.

전역 변수는 코드 어디서든 참조할 수 있지만, 지역 변수는 같은 스코프나 하위 스코프에서만 참조가 가능하다. 즉, 상위 스코프에서는 하위 스코프에서 선언한 변수를 참조할 수 없다는 것이다.

스코프는 서로 체인처럼 이어져 있고, 이를 스코프 체인이라고 한다. 스코프 체인의 최상단에는 전역 스코프가 있고, 그 하위에는 함수들이 존재하며, 함수들의 하위 스코프는 함수 내부에 중첩으로 생성된 함수의 스코프가 존재한다.

이 스코프를 바탕으로 식별자를 찾게 되는데, 내 스코프에 참조하려는 식별자가 존재하지 않는다면 상위 스코프에 해당 식별자가 있는지 확인한다.

```javascript
// 전역
var foo = 1;

function outer() {
  // outer 지역
  var outVar = "outer";
  function inner() {
    // inner 지역

    var inVar = "inner";
    console.log(outVar); // 'outer'
    console.log(inVar); // 'inner'
  }
  inner();

  console.log(outVar); // 'outer'
  console.log(inVar); // ReferenceError: inVar is not defined
}
```

## 환경 레코드

환경 레코드에는 현재 컨텍스트와 관련된 코드의 식별자와 정보들이 순서대로 수집되어 저장된다.
단, 이 수집된 정보는 코드가 실행되기 전 상태의 정보다. 코드 실행 전에 이미 해당 환경의 변수명들을 모두 알고 있게 된다. 이를 보고, `식별자의 선언부가 스코프 최상단으로 끌어올려진 것처럼 동작한다`라고 하며, 용어로는 `호이스팅`이라고 한다.

## 변수의 호이스팅

호이스팅은 변수와 함수가 서로 다르게 동작한다고 할 수 있다. 여기서 함수는 엄밀히 말하면 `함수 선언문`을 의미한다. 우선, 변수의 호이스팅 과정을 알아보자.

자바스크립트에서 변수를 선언할 때 사용되는 키워드는 3가지이다. `var`, `let`, `const`를 사용하여 변수를 선언하는데, 호이스팅이 동작하는 것은 `var`와 나머지 `let`, `const`가 다르게 동작한다.

`var`의 경우 호이스팅이 선언과 함께 초기화하면서 일어난다. 이게 무슨 의미냐면, `var`로 선언한 변수는 호이스팅이 되면서 동시에 초기화도 일어난다는 것이다. 이때, 해당 변수는 `undefined`값으로 초기화된다. 즉, 실제 값이 할당되는 할당문 이전에 해당 변수를 참조하면, `undefined`를 반환하게 된다는 것이다.

```javascript
it("var 키워드로 선언한 변수는 undefined가 할당되어 호이스팅이 일어난다.", () => {
  expect(varA).toEqual(undefined);
  var varA = "a";
  expect(varA).toEqual("a");
});
```

`let`과 `const`는 선언문이 최상단으로 끌어올려지지만, 초기화는 일어나지 않는다. 즉, `let`의 경우는 선언문 이전에, `const`는 할당문 이전에 값을 참조할 수 없다는 것이다. `let`의 경우는 값의 재할당이 가능하기 때문에 할당문 없이 단순히 선언만 가능하지만, `const`의 경우는 선언과 동시에 할당이 필수이기 때문이다.

만약 선언문 이전에 값을 참조하면 어떻게 될까? 그렇게 되면 참조 에러가 발생한다.

```javascript
it("let, const 키워드로 선언한 변수는 초기화 단계 이전에 참조하면 ReferenceError를 던진다.", () => {
  try {
    console.log(letA);
    let letA = "a";
  } catch (e) {
    expect(e).toBeInstanceOf(ReferenceError);
  }
});
```

## 함수의 호이스팅

함수의 호이스팅을 봐보자. 함수를 만드는 방식은 크게 두 가지이다. `함수 선언문을 이용하는 방법`과 `함수 표현식을 이용하는 방법`이다. 일반적으로 이렇게 사용하고, 함수 생성자를 이용하거나 그런 방법이 있지만, 그건 특수한 방식이기 때문에 고려하지 않는다.

`함수 선언문`과 `함수 표현식`의 호이스팅 방식은 서로 다르게 동작한다. 이를 이해하기 위해서는 `문(statement)`과 `표현식(expression)`의 차이를 알아야 한다.

간단하게 말하자면, 표현식은 값으로 사용될 수 있는 코드를 의미하고, 문은 단지 프로그래밍 실행하는 코드 단위이다.

먼저 표현식을 알아보면, 값으로 평가되는 것은 제일 간단하게 볼 수 있는 건 값 그 자체다.

```javascript
const a = 100; // 100은 '값'으로 평가되기 때문에 그 자체로 표현식이다.
const b = 1 + 2; // 1 + 2 는 3이라는 값으로 평가되기 때문에 표현식이다.
```

그렇다면 문은 어떨까? 대표적인 문은 조건문, 반복문 등이 있다. 변수 선언문도 `문`이다.

```javascript
if (true) {
  // ...
}
const b = 20; // 20은 표현식이지만, const b = 20 이라는 변수 선언 및 할당은 문이다.
```

그렇다면, 표현식과 문을 쉽게 구별하는 방법은 뭐가 있을까? 바로 어떤 `변수에 할당`해보는 것이다. 변수에 할당될 수 있는 것은 `값`이다. 즉, 값으로 평가될 수 없는 `문`의 경우 변수에 할당할 수 없다.

```javascript
const foo = 1 + 2 // 표현식은 변수에 할당할 수 있다.
const a = var b // 변수 선언문은 값으로 평가될 수 없기 때문에 변수에 할당할 수 없다.
```

함수도 마찬가지다. 먼저, 함수 선언문을 보면 다음과 같다.

```javascript
function foo() {
  // ...
}
```

변수 선언문은 그 자체로 코드의 최소 실행 단위이다. 함수 표현식은 다음과 같이 작성할 수 있다.

```javascript
const foo = function () {
  // ...
};
```

위 코드는 무기명 함수 표현식을 `foo`라는 변수에 할당한 것이다. 여기서 `function`부터는 표현식에 해당한다. 왜? 변수에 할당할 수 있으니까. 이는 엄밀히 말하면 `함수 선언문`과는 다르다. 그 차이를 알 수 있는 것은 호이스팅이 일어나는 방식을 보면 알 수 있다.

드디어 함수의 호이스팅에 대해서 이야기를 하는데, 먼저 함수 선언문과 표현식 모두 호이스팅이 일어난다. 즉, 스코프의 최상단으로 `선언문이 끌어올려지는 것처럼 동작한다.`
여기서 중요한 것은 `선언문`이 끌어올려진다는 것이다. 이게 왜 중요하냐면,

> 함수의 호이스팅은 사실 `함수 선언문`만 일어나는 것이고, 함수 표현식은 `변수의 호이스팅`으로 동작하기 때문이다.

이해가 안될 수 있지만, 코드의 모양을 보면 눈치를 챌 수 있다. 아까 말했듯이, 함수 표현식은 특정 변수에 할당하는 모양이다. 즉, 호이스팅이 되는 것은 사실 함수 표현식이 할당된 변수라는 것이다.

그렇다면, 함수 선언문은 어떻게 호이스팅될까? 아까 `var` 키워드의 경우 호이스팅되면서 `undefined`가 할당되었다. 함수 선언문의 경우는 함수 자체가 할당되게 된다. 즉, 함수 선언문을 코드가 평가하기 전에 호출해도 문제가 없다는 것이다.

```javascript
it("함수 선언문이 평가되기 전에 참조가 가능합니다.", () => {
  expect(foo()).toEqual("foo");
  function foo() {
    return "foo";
  }
});
```

위 테스트 코드는 문제없이 통과한다. 그렇다면 함수 표현식은 어떨까? 변수의 호이스팅을 따른다면, `var`로 생성했을 때는 `undefined`, `let, const`로 선언했을 때는 참조 에러를 발생시킬 것이다. 여기서 주의할 것은, 함수를 호출했을 때 반환하는 값이 `undefined`이거나 `ReferenceError`가 아니라 함수 자체가 이 값들을 갖는다는 것이다.

```javascript
it("var 키워드로 만든 함수는 undefined로 초기화됩니다.", () => {
  expect(foo).toEqual(undefined);
  var foo = function () {
    return "foo";
  };
});
it("let 키워드로 만든 함수는 선언 이전에 참조하면 에러를 발생시킵니다.", () => {
  try {
    console.log(foo);
    let foo = function () {
      return "foo";
    };
  } catch (e) {
    expect(e).toBeInstanceOf(ReferenceError);
  }
});
```
